// Machine generated by peg-sharp 0.3.408.0 from generate/NewParser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Xml;

[Serializable]
internal sealed class ParserException : Exception
{
	public ParserException()
	{
	}
	
	public ParserException(string message) : base(message)
	{
	}
	
	public ParserException(int line, int col, string file, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
	{
	}
	
	public ParserException(int line, int col, string file, string format, params object[] args) : this(line, col, file, string.Format(format, args))
	{
	}
	
	public ParserException(int line, int col, string file, string message, Exception inner) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."), inner)
	{
	}
	
	[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
	private ParserException(SerializationInfo info, StreamingContext context) : base(info, context)
	{
	}
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class NewParser
{
	public NewParser()
	{
		m_nonterminals.Add("Header", new ParseMethod[]{this.DoParseHeaderRule});
		m_nonterminals.Add("ExternC", new ParseMethod[]{this.DoParseExternCRule});
		m_nonterminals.Add("ExternBegin", new ParseMethod[]{this.DoParseExternBeginRule});
		m_nonterminals.Add("ExternEnd", new ParseMethod[]{this.DoParseExternEndRule});
		m_nonterminals.Add("ForwardReference", new ParseMethod[]{this.DoParseForwardReference1Rule, this.DoParseForwardReference2Rule});
		m_nonterminals.Add("Enum", new ParseMethod[]{this.DoParseEnum1Rule, this.DoParseEnum2Rule});
		m_nonterminals.Add("EnumEntries", new ParseMethod[]{this.DoParseEnumEntriesRule});
		m_nonterminals.Add("EnumEntry", new ParseMethod[]{this.DoParseEnumEntry1Rule, this.DoParseEnumEntry2Rule});
		m_nonterminals.Add("Expression", new ParseMethod[]{this.DoParseExpressionRule});
		m_nonterminals.Add("BinaryOp", new ParseMethod[]{this.DoParseBinaryOpRule});
		m_nonterminals.Add("PrimitiveExpression", new ParseMethod[]{this.DoParsePrimitiveExpression1Rule, this.DoParsePrimitiveExpression2Rule, this.DoParsePrimitiveExpression3Rule, this.DoParsePrimitiveExpression4Rule, this.DoParsePrimitiveExpression5Rule, this.DoParsePrimitiveExpression6Rule});
		m_nonterminals.Add("Extern", new ParseMethod[]{this.DoParseExtern1Rule, this.DoParseExtern2Rule, this.DoParseExtern3Rule, this.DoParseExtern4Rule});
		m_nonterminals.Add("MoreExterns", new ParseMethod[]{this.DoParseMoreExterns1Rule, this.DoParseMoreExterns2Rule});
		m_nonterminals.Add("ExternMacro", new ParseMethod[]{this.DoParseExternMacro1Rule, this.DoParseExternMacro2Rule});
		m_nonterminals.Add("Inline", new ParseMethod[]{this.DoParseInline1Rule, this.DoParseInline2Rule});
		m_nonterminals.Add("ArgList", new ParseMethod[]{this.DoParseArgListRule});
		m_nonterminals.Add("Arg", new ParseMethod[]{this.DoParseArg1Rule, this.DoParseArg2Rule});
		m_nonterminals.Add("Body", new ParseMethod[]{this.DoParseBodyRule});
		m_nonterminals.Add("Interface", new ParseMethod[]{this.DoParseInterface1Rule, this.DoParseInterface2Rule});
		m_nonterminals.Add("Attribute", new ParseMethod[]{this.DoParseAttributeRule});
		m_nonterminals.Add("InterfaceMember", new ParseMethod[]{this.DoParseInterfaceMemberRule});
		m_nonterminals.Add("InterfaceSig", new ParseMethod[]{this.DoParseInterfaceSig1Rule, this.DoParseInterfaceSig2Rule, this.DoParseInterfaceSig3Rule, this.DoParseInterfaceSig4Rule, this.DoParseInterfaceSig5Rule, this.DoParseInterfaceSig6Rule});
		m_nonterminals.Add("BaseClass", new ParseMethod[]{this.DoParseBaseClassRule});
		m_nonterminals.Add("Category", new ParseMethod[]{this.DoParseCategoryRule});
		m_nonterminals.Add("Fields", new ParseMethod[]{this.DoParseFieldsRule});
		m_nonterminals.Add("Access", new ParseMethod[]{this.DoParseAccessRule});
		m_nonterminals.Add("Field", new ParseMethod[]{this.DoParseField1Rule, this.DoParseField2Rule});
		m_nonterminals.Add("FieldNames", new ParseMethod[]{this.DoParseFieldNamesRule});
		m_nonterminals.Add("FieldName", new ParseMethod[]{this.DoParseFieldName1Rule, this.DoParseFieldName2Rule, this.DoParseFieldName3Rule, this.DoParseFieldName4Rule});
		m_nonterminals.Add("Package", new ParseMethod[]{this.DoParsePackageRule});
		m_nonterminals.Add("Property", new ParseMethod[]{this.DoParseProperty1Rule, this.DoParseProperty2Rule});
		m_nonterminals.Add("PropertyArgs", new ParseMethod[]{this.DoParsePropertyArgsRule});
		m_nonterminals.Add("PropertyArg", new ParseMethod[]{this.DoParsePropertyArg1Rule, this.DoParsePropertyArg2Rule});
		m_nonterminals.Add("MethodName", new ParseMethod[]{this.DoParseMethodNameRule});
		m_nonterminals.Add("Method", new ParseMethod[]{this.DoParseMethodRule});
		m_nonterminals.Add("Parameter", new ParseMethod[]{this.DoParseParameterRule});
		m_nonterminals.Add("VarArgs", new ParseMethod[]{this.DoParseVarArgsRule});
		m_nonterminals.Add("ParensType", new ParseMethod[]{this.DoParseParensTypeRule});
		m_nonterminals.Add("ParenType", new ParseMethod[]{this.DoParseParenTypeRule});
		m_nonterminals.Add("Protocol", new ParseMethod[]{this.DoParseProtocolRule});
		m_nonterminals.Add("ProtocolList", new ParseMethod[]{this.DoParseProtocolListRule});
		m_nonterminals.Add("Struct", new ParseMethod[]{this.DoParseStruct1Rule, this.DoParseStruct2Rule, this.DoParseStruct3Rule, this.DoParseStruct4Rule});
		m_nonterminals.Add("Volatile", new ParseMethod[]{this.DoParseVolatileRule});
		m_nonterminals.Add("Typedef", new ParseMethod[]{this.DoParseTypedef1Rule, this.DoParseTypedef2Rule, this.DoParseTypedef3Rule, this.DoParseTypedef4Rule});
		m_nonterminals.Add("Type", new ParseMethod[]{this.DoParseType1Rule, this.DoParseType2Rule, this.DoParseType3Rule, this.DoParseType4Rule});
		m_nonterminals.Add("TypeList", new ParseMethod[]{this.DoParseTypeListRule});
		m_nonterminals.Add("PrimitiveType", new ParseMethod[]{this.DoParsePrimitiveType1Rule, this.DoParsePrimitiveType2Rule, this.DoParsePrimitiveType3Rule, this.DoParsePrimitiveType4Rule});
		m_nonterminals.Add("TypePrefix", new ParseMethod[]{this.DoParseTypePrefixRule});
		m_nonterminals.Add("TypeSuffix", new ParseMethod[]{this.DoParseTypeSuffixRule});
		m_nonterminals.Add("ArraySuffix", new ParseMethod[]{this.DoParseArraySuffixRule});
		m_nonterminals.Add("IntegralType", new ParseMethod[]{this.DoParseIntegralTypeRule});
		m_nonterminals.Add("Union", new ParseMethod[]{this.DoParseUnionRule});
		m_nonterminals.Add("Availability", new ParseMethod[]{this.DoParseAvailabilityRule});
		m_nonterminals.Add("Deprecated", new ParseMethod[]{this.DoParseDeprecated1Rule, this.DoParseDeprecated2Rule, this.DoParseDeprecated3Rule, this.DoParseDeprecated4Rule, this.DoParseDeprecated5Rule});
		m_nonterminals.Add("Unavailable", new ParseMethod[]{this.DoParseUnavailableRule});
		m_nonterminals.Add("Format", new ParseMethod[]{this.DoParseFormatRule});
		m_nonterminals.Add("Float", new ParseMethod[]{this.DoParseFloatRule});
		m_nonterminals.Add("FloatSuffix", new ParseMethod[]{this.DoParseFloatSuffixRule});
		m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifierRule});
		m_nonterminals.Add("IdentifierNoSpace", new ParseMethod[]{this.DoParseIdentifierNoSpaceRule});
		m_nonterminals.Add("IdentifierStart", new ParseMethod[]{this.DoParseIdentifierStartRule});
		m_nonterminals.Add("IdentifierMiddle", new ParseMethod[]{this.DoParseIdentifierMiddleRule});
		m_nonterminals.Add("IdentifierList", new ParseMethod[]{this.DoParseIdentifierListRule});
		m_nonterminals.Add("Keyword", new ParseMethod[]{this.DoParseKeywordRule});
		m_nonterminals.Add("BuiltinType", new ParseMethod[]{this.DoParseBuiltinTypeRule});
		m_nonterminals.Add("Integer", new ParseMethod[]{this.DoParseInteger1Rule, this.DoParseInteger2Rule});
		m_nonterminals.Add("IntegerList", new ParseMethod[]{this.DoParseIntegerListRule});
		m_nonterminals.Add("IntegerSuffix", new ParseMethod[]{this.DoParseIntegerSuffixRule});
		m_nonterminals.Add("C", new ParseMethod[]{this.DoParseCRule});
		m_nonterminals.Add("Comment", new ParseMethod[]{this.DoParseComment1Rule, this.DoParseComment2Rule});
		m_nonterminals.Add("Preprocessor", new ParseMethod[]{this.DoParsePreprocessor1Rule, this.DoParsePreprocessor2Rule});
		m_nonterminals.Add("PreprocessName", new ParseMethod[]{this.DoParsePreprocessNameRule});
		m_nonterminals.Add("DefineValue", new ParseMethod[]{this.DoParseDefineValueRule});
		m_nonterminals.Add("Continuation", new ParseMethod[]{this.DoParseContinuationRule});
		m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
		m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
		OnCtorEpilog();
	}
	
	public XmlNode Parse(string input)
	{
		return DoParseFile(input, null);
	}
	
	// File is used for error reporting.
	public XmlNode Parse(string input, string file)
	{
		return DoParseFile(input, file);
	}
	
	#region Non-Terminal Parse Methods
	// Header := S (Comment / Preprocessor / ForwardReference / Enum / ExternC / ExternBegin / ExternEnd / Extern / Inline / Interface / Protocol / Struct / Typedef)*
	private State DoParseHeaderRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Preprocessor");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ForwardReference");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Enum");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ExternC");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ExternBegin");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ExternEnd");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Extern");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Inline");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Interface");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Protocol");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Struct");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Typedef");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Header", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternC := 'extern' S '"C"' S '{' S Header '}' S
	private State DoParseExternCRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "extern");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"C\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Header");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternC", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value = results[3].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternBegin := [A-Z]+ '_EXTERN_C_BEGIN' S
	private State DoParseExternBeginRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_EXTERN_C_BEGIN");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternBegin", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternEnd := [A-Z]+ '_EXTERN_C_END' S
	private State DoParseExternEndRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_EXTERN_C_END");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternEnd", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ForwardReference := Deprecated? ('@class' / '@protocol') S IdentifierList ';' S
	private State DoParseForwardReference1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@class");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@protocol");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ForwardReference", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ForwardReference := Type ('NP_LOADDS' S)? Identifier '(' S ArgList? ')' S ';' S
	private State DoParseForwardReference2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "NP_LOADDS");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ForwardReference", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Enum := 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Deprecated? ';' C
	private State DoParseEnum1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "enum");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "EnumEntries");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ",");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Enum", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Enum := 'typedef' C 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Identifier Deprecated? ';' C
	private State DoParseEnum2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "enum");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "EnumEntries");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ",");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Enum", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntries := EnumEntry (('#else' / (C ',')) C EnumEntry S)*
	private State DoParseEnumEntriesRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "EnumEntry");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "#else");},
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "C");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ",");});});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "EnumEntry");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntries", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntry := Identifier '=' S Expression
	private State DoParseEnumEntry1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Expression");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntry", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntry := Identifier
	private State DoParseEnumEntry2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntry", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Expression := PrimitiveExpression (BinaryOp PrimitiveExpression)*
	private State DoParseExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "BinaryOp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PrimitiveExpression");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Expression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "expression";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// BinaryOp := ('+' / '-' / '*' / '/' / '%' / '<<' / '>>' / '&' / '|') S
	private State DoParseBinaryOpRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "+");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "-");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "*");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "/");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "%");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "<<");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ">>");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "&");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "|");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BinaryOp", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "binary operator";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Float
	private State DoParsePrimitiveExpression1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Float");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Integer
	private State DoParsePrimitiveExpression2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Integer");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Identifier
	private State DoParsePrimitiveExpression3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := ''\\''' S
	private State DoParsePrimitiveExpression4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "'\\''");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := ''' [^'\r\n]+ ''' S
	private State DoParsePrimitiveExpression5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "'");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "'\r\n", string.Empty, null, "[^'\r\n]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "'");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "5");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := '(' S Expression ')' S
	private State DoParsePrimitiveExpression6Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Expression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "6");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := 'extern' S Type Identifier MoreExterns* C Deprecated? Availability? ';' C
	private State DoParseExtern1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "extern");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "MoreExterns");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := 'extern'? S Type Identifier '(' S ArgList? ')' C Deprecated? Availability? ';' C
	private State DoParseExtern2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "extern");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := ExternMacro Type Identifier '(' S ArgList? ')' C Deprecated? Availability? Deprecated? ';' C
	private State DoParseExtern3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "ExternMacro");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := ExternMacro Type Identifier MoreExterns* C Deprecated? Availability? Deprecated? ';' C
	private State DoParseExtern4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "ExternMacro");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "MoreExterns");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MoreExterns := ',' S '*' S Identifier
	private State DoParseMoreExterns1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MoreExterns", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			value.InnerText = "*" + results[2].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MoreExterns := ',' S Identifier
	private State DoParseMoreExterns2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MoreExterns", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			value.InnerText = results[1].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternMacro := [A-Z]+ '_EXPORT' S
	private State DoParseExternMacro1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_EXPORT");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternMacro", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternMacro := [A-Z]+ '_EXTERN' S
	private State DoParseExternMacro2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_EXTERN");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternMacro", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Inline := 'NS_INLINE' S Type Identifier '(' S ArgList? ')' S Body
	private State DoParseInline1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "NS_INLINE");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Body");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Inline", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Inline := 'static' S '__inline__' S Type Identifier '(' S ArgList? ')' S Body
	private State DoParseInline2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "static");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "__inline__");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Body");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Inline", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ArgList := Arg (',' S Arg)*
	private State DoParseArgListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Arg");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Arg");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ArgList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Arg := '...'
	private State DoParseArg1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, "...");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Arg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Arg := Type (Identifier ArraySuffix*)?
	private State DoParseArg2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "ArraySuffix");});});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Arg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Body := '{' S ([^{}] / Body)+ '}' S
	private State DoParseBodyRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, true, "{}", string.Empty, null, "[^{}]");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Body");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Body", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Interface := Attribute? Deprecated? Availability? '@interface' C InterfaceSig ('{' C)? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C
	private State DoParseInterface1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Attribute");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@interface");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "InterfaceSig");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "{");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@interface");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "InterfaceSig");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "{");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Fields");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "}");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ";");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");});});});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "InterfaceMember");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@end");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Interface", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Interface := Attribute? Deprecated? Availability? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C
	private State DoParseInterface2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Attribute");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@interface");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "InterfaceSig");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "{");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Fields");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "}");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ";");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");});});});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "InterfaceMember");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@end");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Interface", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Attribute := '__attribute__' C '((' S Identifier '))' C
	private State DoParseAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "__attribute__");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "((");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "))");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Attribute", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceMember := Comment / Preprocessor / Method / Enum / Extern / Property / Typedef / ('@optional' S) / ('@required' S)
	private State DoParseInterfaceMemberRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Comment");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Preprocessor");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Method");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Enum");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Extern");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Property");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Typedef");},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@optional");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@required");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceMember", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C ProtocolList ProtocolList
	private State DoParseInterfaceSig1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "BaseClass");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ProtocolList");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ProtocolList");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C ProtocolList C
	private State DoParseInterfaceSig2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "BaseClass");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ProtocolList");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C
	private State DoParseInterfaceSig3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "BaseClass");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier C ProtocolList
	private State DoParseInterfaceSig4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ProtocolList");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier Category ProtocolList
	private State DoParseInterfaceSig5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Category");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ProtocolList");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "5");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier Category
	private State DoParseInterfaceSig6Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Category");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "6");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// BaseClass := ':' S Identifier
	private State DoParseBaseClassRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BaseClass", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Category := '(' S Identifier ')' C
	private State DoParseCategoryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Category", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Fields := (Comment / Preprocessor / Access / Field / Struct / Union / Package)*
	private State DoParseFieldsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Comment");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Preprocessor");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Access");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Field");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Struct");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Union");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Package");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Fields", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Access := ('@private' / '@protected' / '@public') S (';' S)?
	private State DoParseAccessRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@private");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@protected");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "@public");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ";");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Access", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Field := Volatile? Type FieldNames Deprecated? ';' S
	private State DoParseField1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FieldNames");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Field", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Field := Volatile? Type Deprecated? ';' S
	private State DoParseField2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Field", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldNames := FieldName (',' S FieldName)*
	private State DoParseFieldNamesRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "FieldName");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "FieldName");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldNames", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier ArraySuffix+
	private State DoParseFieldName1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArraySuffix");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier? ':' S Integer
	private State DoParseFieldName2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := '*' S Identifier
	private State DoParseFieldName3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier
	private State DoParseFieldName4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Package := '@package' S
	private State DoParsePackageRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@package");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Package", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Property := '@property' S '(' S PropertyArgs ')' S Field
	private State DoParseProperty1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@property");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PropertyArgs");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Field");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Property", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Property := '@property' S Field
	private State DoParseProperty2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@property");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Field");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Property", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArgs := PropertyArg (S ',' S PropertyArg)* S
	private State DoParsePropertyArgsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PropertyArg");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PropertyArg");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArgs", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArg := Identifier '=' S MethodName
	private State DoParsePropertyArg1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "MethodName");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArg := Identifier
	private State DoParsePropertyArg2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MethodName := Identifier (':' Identifier?)*
	private State DoParseMethodNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ":");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MethodName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Method := ('-' / '+') S ParensType? ((Parameter+ VarArgs?) / Identifier) Deprecated? Unavailable? Availability? Format? ';' S
	private State DoParseMethodRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "-");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "+");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ParensType");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 1, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Parameter");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "VarArgs");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Unavailable");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Format");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Method", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Parameter := Identifier? ':' S ParensType? Identifier
	private State DoParseParameterRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ParensType");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Parameter", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// VarArgs := ',' S '...' S ('NS_REQUIRES_NIL_TERMINATION' S)?
	private State DoParseVarArgsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "...");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "NS_REQUIRES_NIL_TERMINATION");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("VarArgs", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ParensType := '(' S ParenType C ')' S
	private State DoParseParensTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ParenType");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ParensType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value.InnerText = results[1].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ParenType := Type ArraySuffix*
	private State DoParseParenTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArraySuffix");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ParenType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Protocol := Deprecated? Availability? '@protocol' C Identifier ProtocolList? InterfaceMember* '@end' C
	private State DoParseProtocolRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Availability");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@protocol");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ProtocolList");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "InterfaceMember");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@end");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Protocol", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ProtocolList := '<' C IdentifierList '>' C
	private State DoParseProtocolListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "<");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ">");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ProtocolList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value = results[1].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := 'typedef' C Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union / Struct)* '}' C Identifier ArraySuffix* Deprecated? ';' C
	private State DoParseStruct1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "struct");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Preprocessor");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Field");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Union");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Struct");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArraySuffix");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union)* '}' C Identifier? ArraySuffix* Deprecated? ';' C
	private State DoParseStruct2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "struct");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Preprocessor");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Field");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Union");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArraySuffix");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := 'typedef' C Volatile? 'struct' C Identifier Identifier Deprecated? ';' C
	private State DoParseStruct3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "struct");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := Volatile? 'struct' C Identifier Deprecated? ';' C
	private State DoParseStruct4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Volatile");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "struct");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Volatile := 'volatile' S
	private State DoParseVolatileRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "volatile");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Volatile", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S Type Identifier '(' S ArgList? ')' S ';' S
	private State DoParseTypedef1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S PrimitiveType '(' S '*' Identifier ')' S '(' S ArgList? ')' S ';' S
	private State DoParseTypedef2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveType");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S Type Identifier ';' S
	private State DoParseTypedef3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S 'CALLBACK_API' S '(' S TypeList ')' S '(' S ArgList? ')' S ';' S
	private State DoParseTypedef4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "typedef");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "CALLBACK_API");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "TypeList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType '(*)' S '(' S TypeList ')' S
	private State DoParseType1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveType");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(*)");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "TypeList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType '(^)' S '(' S ArgList ')' S
	private State DoParseType2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveType");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(^)");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ArgList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType '(' S '*' S Identifier ')' S '(' S ArgList? ')' S
	private State DoParseType3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveType");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ArgList");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType
	private State DoParseType4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "PrimitiveType");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			value.InnerText = results[0].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// TypeList := Type (',' S Type)*
	private State DoParseTypeListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Type");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Type");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypeList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := ('unsigned' S)? 'long' S 'long' S TypeSuffix*
	private State DoParsePrimitiveType1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "unsigned");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "long");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "long");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TypeSuffix");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := 'unsigned' S IntegralType? TypeSuffix*
	private State DoParsePrimitiveType2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "unsigned");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IntegralType");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TypeSuffix");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := Identifier Comment S '*' S
	private State DoParsePrimitiveType3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Comment");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			value.InnerText = results[0].Value.InnerText + "*";
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := TypePrefix* (Identifier / BuiltinType) TypeSuffix*
	private State DoParsePrimitiveType4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TypePrefix");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "BuiltinType");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TypeSuffix");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TypePrefix := ('const' / 'IBOutlet' / 'inout' / 'oneway' / 'out' / 'signed' / '__strong' / 'struct' / 'unsigned' / '__weak') S
	private State DoParseTypePrefixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "const");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "IBOutlet");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "inout");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "oneway");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "out");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "signed");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "__strong");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "struct");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "unsigned");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "__weak");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypePrefix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TypeSuffix := ('*' / 'const' / '__strong' / '__weak' / ArraySuffix+ / ProtocolList) S
	private State DoParseTypeSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "*");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "const");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "__strong");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "__weak");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ArraySuffix");});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "ProtocolList");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypeSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type suffix";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// ArraySuffix := '[' S (Integer / Identifier)? ']' S
	private State DoParseArraySuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "[");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Integer");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "]");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ArraySuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IntegralType := ('char' / 'short' / 'int' / 'long') S
	private State DoParseIntegralTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "char");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "short");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "int");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "long");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IntegralType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Union := 'union' C '{' S (Comment / Preprocessor / Field / Struct)* '}' C Identifier Deprecated? ';' C
	private State DoParseUnionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "union");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Preprocessor");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Field");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Struct");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Deprecated");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ";");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Union", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Availability := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' S
	private State DoParseAvailabilityRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_AND_LATER");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Availability", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ S
	private State DoParseDeprecated1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER_BUT_DEPRECATED' S
	private State DoParseDeprecated2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_AND_LATER_BUT_DEPRECATED");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' C
	private State DoParseDeprecated3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "DEPRECATED_IN_MAC_OS_X_VERSION_10_");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_AND_LATER");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := [A-Z]+ '_DEPRECATED' C
	private State DoParseDeprecated4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_DEPRECATED");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := '__attribute__((deprecated))' C
	private State DoParseDeprecated5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "__attribute__((deprecated))");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "5");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Unavailable := 'UNAVAILABLE_ATTRIBUTE' C
	private State DoParseUnavailableRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "UNAVAILABLE_ATTRIBUTE");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Unavailable", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Format := 'NS_FORMAT_FUNCTION' S '(' S IntegerList ')' S
	private State DoParseFormatRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "NS_FORMAT_FUNCTION");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IntegerList");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Format", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Float := '-'? [0-9]+ '.' [0-9]+ FloatSuffix? S
	private State DoParseFloatRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "-");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ".");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "FloatSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Float", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "float";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// FloatSuffix := 'f'
	private State DoParseFloatSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, "f");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FloatSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Identifier := IdentifierNoSpace S
	private State DoParseIdentifierRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierNoSpace");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Identifier", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierNoSpace := !Keyword IdentifierStart IdentifierMiddle*
	private State DoParseIdentifierNoSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoNAssert(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Keyword");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierStart");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IdentifierMiddle");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierNoSpace", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierStart := [_a-zA-Z]
	private State DoParseIdentifierStartRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, "_", "azAZ", null, "[_a-zA-Z]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierStart", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierMiddle := [_a-zA-Z0-9]
	private State DoParseIdentifierMiddleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, "_", "azAZ09", null, "[_a-zA-Z0-9]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierMiddle", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier characters";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierList := Identifier (C ',' S Identifier)* C
	private State DoParseIdentifierListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "C");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "C");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Keyword := ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'double' / 'do' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'int' / 'long' / 'register' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while') !IdentifierMiddle
	private State DoParseKeywordRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "auto");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "break");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "case");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "char");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "const");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "continue");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "default");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "double");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "do");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "else");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "enum");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "extern");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "float");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "for");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "goto");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "if");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "int");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "long");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "register");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "return");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "short");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "signed");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "sizeof");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "static");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "struct");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "switch");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "typedef");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "union");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "unsigned");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "void");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "volatile");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "while");});},
			delegate (State s, List<Result> r) {return DoNAssert(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IdentifierMiddle");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Keyword", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// BuiltinType := ('char' / 'double' / 'float' / 'int' / 'long' / 'short' / 'void') !IdentifierMiddle S
	private State DoParseBuiltinTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "char");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "double");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "float");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "int");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "long");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "short");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "void");});},
			delegate (State s, List<Result> r) {return DoNAssert(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IdentifierMiddle");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BuiltinType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Integer := '0' [xX] [0-9a-fA-F]+ IntegerSuffix? S
	private State DoParseInteger1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "0");},
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, "xX", string.Empty, null, "[xX]");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09afAF", null, "[0-9a-fA-F]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IntegerSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Integer", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "integer";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Integer := '-'? [0-9]+ IntegerSuffix? S
	private State DoParseInteger2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "-");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IntegerSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Integer", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "integer";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IntegerList := Integer (',' S Integer)*
	private State DoParseIntegerListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Integer");});});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IntegerList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IntegerSuffix := ('LL' / 'L' / 'ULL' / 'UL' / 'U') S
	private State DoParseIntegerSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "LL");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "L");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "ULL");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "UL");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "U");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IntegerSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// C := (Comment / Preprocessor / Space)*
	private State DoParseCRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Comment");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Preprocessor");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Space");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("C", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Comment := '/*' (!'*/' .)* '*/' S
	private State DoParseComment1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "/*");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoNAssert(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "*/");});},
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "\x0001\xFFFF", null, ".");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*/");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Comment", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "comment";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Comment := '//' [^\n\r]* S
	private State DoParseComment2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "//");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\n\r", string.Empty, null, "[^\n\r]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Comment", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "comment";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Preprocessor := '#' S 'define' [ \t]+ IdentifierNoSpace !'(' DefineValue S
	private State DoParsePreprocessor1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "#");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "define");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, " \t", string.Empty, null, "[ \t]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierNoSpace");},
			delegate (State s, List<Result> r) {return DoNAssert(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "(");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefineValue");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Preprocessor", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "preprocessor directive";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Preprocessor := '#' S PreprocessName [^\n\r\\]* Continuation* S
	private State DoParsePreprocessor2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "#");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PreprocessName");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\n\r\\", string.Empty, null, "[^\n\r\\]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Continuation");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Preprocessor", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "preprocessor directive";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// PreprocessName := 'define' / 'elif' / 'else' / 'endif' / 'error' / 'if' / 'import' / 'include' / 'pragma' / 'undef' / 'warning'
	private State DoParsePreprocessNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "define");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "elif");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "else");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "endif");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "error");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "if");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "import");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "include");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "pragma");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "undef");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "warning");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PreprocessName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DefineValue := [^\n\r\\]+
	private State DoParseDefineValueRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, true, "\n\r\\", string.Empty, null, "[^\n\r\\]");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("DefineValue", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Continuation := '\\\n' [^\n\r\\]* Continuation*
	private State DoParseContinuationRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\\\n");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\n\r\\", string.Empty, null, "[^\n\r\\]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Continuation");});});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Continuation", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// S := Space*
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Space");});
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("S", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Space := [ \t\r\n]
	private State DoParseSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Space", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "whitespace";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
	
	private XmlNode DoParseFile(string input, string file)
	{
		m_doc = new XmlDocument();
		m_file = file;
		m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";	// add a sentinel so we can avoid range checks
		m_cache.Clear();
		
		State state = new State(0, true);
		List<Result> results = new List<Result>();
		
		OnParseProlog();
		state = DoParse(state, results, "Header");
		
		int i = state.Index;
		if (!state.Parsed)
			DoThrow(state.Errors.Index, state.Errors.ToString());
		else if (i < input.Length)
			if (state.Errors.Expected.Length > 0)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else
				DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
		
		m_doc.AppendChild(results[0].Value);
		OnParseEpilog(state);
		
		return m_doc;
	}
	
	public string DoEscapeAll(string s)
	{
		System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	// This is normally only used for error handling so it doesn't need to be too
	// fast. If it somehow does become a bottleneck for some parsers they can
	// replace it with the custom-methods setting.
	private int DoGetLine(int index)
	{
		int line = 1;
		
		int i = 0;
		while (i <= index)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				++i;
				++line;
			}
			else if (ch == '\r')
			{
				++line;
			}
			else if (ch == '\n')
			{
				++line;
			}
		}
		
		return line;
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index + 1;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index);
	
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, m_file, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, m_file, DoEscapeAll(format));
	}
	
	private XmlText DoCreateTextNode(string data, int line, int col)
	{
		XmlText node = m_doc.CreateTextNode(data);
		
		return node;
	}
	
	private XmlElement DoCreateElementNode(string name, int offset, int length, int line, int col, XmlNode[] children)
	{
		XmlElement node = m_doc.CreateElement(name);
		
		node.SetAttribute("offset", offset.ToString());
		node.SetAttribute("length", length.ToString());
		node.SetAttribute("line", line.ToString());
		node.SetAttribute("col", col.ToString());
		
		foreach (XmlNode child in children)
			node.AppendChild(child);
		
		return node;
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		int j = state.Index;
		
		for (int i = 0; i < literal.Length; ++i)
		{
			if (m_input[j + i] != literal[i])
			{
				return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
			}
		}
		
		int k = j + literal.Length;
		
		results.Add(new Result(this, j, literal.Length, m_input, DoCreateTextNode(literal, DoGetLine(j), DoGetCol(j))));
		state = new State(k, true, state.Errors);
		
		return state;
	}
	
	private State DoParse(State state, List<Result> results, string nonterminal)
	{
		State start = state;
		
		CacheValue cache;
		CacheKey key = new CacheKey(nonterminal, start.Index);
		if (!m_cache.TryGetValue(key, out cache))
		{
			ParseMethod[] methods = m_nonterminals[nonterminal];
			
			int oldCount = results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && results.Count > oldCount;
			XmlNode value = hasResult ? results[results.Count - 1].Value : default(XmlNode);
			cache = new CacheValue(state, value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult)
				results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
		}
		
		return cache.State;
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
				break;
			}
		}
		
		return state;
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		State start = state;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
				state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
				break;
			}
		}
		
		if (count < min || count > max)
			state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
		
		return state;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
			results.Add(new Result(this, state.Index, 1, m_input, DoCreateTextNode(m_input.Substring(state.Index, 1), DoGetLine(state.Index), DoGetCol(state.Index))));
			return new State(state.Index + 1, true, state.Errors);
		}
		
		return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
	}
	
	private State DoNAssert(State state, List<Result> results, ParseMethod method)
	{
		State temp = method(state, results);
		
		state = new State(state.Index, !temp.Parsed, state.Errors);
		
		return state;
	}
	#endregion
	
	#region Private Types
	private struct CacheKey : IEquatable<CacheKey>
	{
		public CacheKey(string rule, int index)
		{
			m_rule = rule;
			m_index = index;
		}
		
		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			
			if (GetType() != obj.GetType())
				return false;
			
			CacheKey rhs = (CacheKey) obj;
			return this == rhs;
		}
		
		public bool Equals(CacheKey rhs)
		{
			return this == rhs;
		}
		
		public static bool operator==(CacheKey lhs, CacheKey rhs)
		{
			if (lhs.m_rule != rhs.m_rule)
				return false;
			
			if (lhs.m_index != rhs.m_index)
				return false;
			
			return true;
		}
		
		public static bool operator!=(CacheKey lhs, CacheKey rhs)
		{
			return !(lhs == rhs);
		}
		
		public override int GetHashCode()
		{
			int hash = 0;
			
			unchecked
			{
				hash += m_rule.GetHashCode();
				hash += m_index.GetHashCode();
			}
			
			return hash;
		}
		
		private string m_rule;
		private int m_index;
	}
	
	private struct CacheValue
	{
		public CacheValue(State state, XmlNode value, bool hasResult)
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State;
		
		public XmlNode Value;
		
		public bool HasResult;
	}
	
	private delegate State ParseMethod(State state, List<Result> results);
	
	// These are either an error that caused parsing to fail or the reason a
	// successful parse stopped.
	private struct ErrorSet
	{
		public ErrorSet(int index, string expected)
		{
			Index = index;
			Expected = new string[]{expected};
		}
		
		public ErrorSet(int index, string[] expected)
		{
			Index = index;
			Expected = expected;
		}
		
		// The location associated with the errors. For a failed parse this will be the
		// same as State.Index. For a successful parse it will be State.Index or later.
		public int Index;
		
		// This will be the name of something which was expected, but not found.
		public string[] Expected;
		
		public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
		{
			if (lhs.Index > rhs.Index)
			{
				return lhs;
			}
			else if (lhs.Index < rhs.Index)
			{
				return rhs;
			}
			else
			{
				List<string> errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
				errors.AddRange(lhs.Expected);
				foreach (string err in rhs.Expected)
				{
					if (errors.IndexOf(err) < 0)
						errors.Add(err);
				}
				return new ErrorSet(lhs.Index, errors.ToArray());
			}
		}
		
		public override string ToString()
		{
			if (Expected.Length > 0)
				return string.Format("Expected {0}", string.Join(" or ", Expected));
			else
				return "<none>";
		}
	}
	
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
			Errors = new ErrorSet(index, new string[0]);
		}
		
		public State(int index, bool parsed, ErrorSet errors)
		{
			Index = index;
			Parsed = parsed;
			Errors = errors;
		}
		
		// Index of the first unconsumed character.
		public int Index;
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed;
		
		// If Parsed is false then this will explain why. If Parsed is true it will
		// say why the parse stopped.
		public ErrorSet Errors;
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
		public Result(NewParser parser, int index, int length, string input, XmlNode value)
		{
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
		
		// For non-terminals this will be the result of the semantic action, 
		// otherwise it will be the default value.
		public XmlNode Value;
		
		private NewParser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
	
	#endregion
	
	#region Fields
	private string m_input;
	private string m_file;
	private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
	private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
	private XmlDocument m_doc;
	#endregion
}
