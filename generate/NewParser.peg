# peg-sharp grammar used to parse Objective-C headers.# See <http://code.google.com/p/peg-sharp/> for more details.# TODO: It would be a bit better if we preprocessed the file instead of simply# ignoring #if's.start = Headervalue = XmlNodeusing = System.Linqdebug = nonedebug-file =# Top LevelHeader := S (Comment / Preprocessor / ForwardReference / Enum / ExternC / ExternBegin / ExternEnd / Extern / Inline / Interface / Protocol / Struct / Typedef)*;ExternC := 'extern' S '"C"' S '{' S Header '}' S	`value = results[3].Value`ExternBegin := [A-Z]+ '_EXTERN_C_BEGIN' S;ExternEnd := [A-Z]+ '_EXTERN_C_END' S;ForwardReference := Deprecated? ('@class' / '@protocol') S IdentifierList ';' S;ForwardReference := Type ('NP_LOADDS' S)? Identifier '(' S ArgList? ')' S ';' S;# EnumEnum := 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Deprecated? ';' C;Enum := 'typedef' C 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Identifier Deprecated? ';' C;EnumEntries := EnumEntry (('#else' / C ',') C EnumEntry S)*;EnumEntry := Identifier '=' S Expression;EnumEntry := Identifier;# ExpressionExpression := PrimitiveExpression (BinaryOp PrimitiveExpression)* `value.InnerText = text.Trim()` `expected = "expression"`BinaryOp := ('+' / '-' / '*' / '/' / '%' / '<<' / '>>' / '&' / '|') S `;` `expected = "binary operator"`PrimitiveExpression := Float;PrimitiveExpression := Integer;PrimitiveExpression := Identifier;PrimitiveExpression := "'\\''" S;PrimitiveExpression := "'" [^'\r\n]+ "'" S;PrimitiveExpression := '(' S Expression ')' S;# ExternExtern := 'extern' S Type Identifier MoreExterns* C Deprecated? Availability? Refcount? ';' C;Extern := 'extern'? S Type Identifier '(' S ArgList? ')' C Deprecated? Availability? Refcount? ';' C;Extern := ExternMacro Type Identifier '(' S ArgList? ')' C Deprecated? Availability? Deprecated? Refcount? ';' C;Extern := ExternMacro Type Identifier MoreExterns* C Deprecated? Availability? Deprecated? Refcount? ';' C;MoreExterns := ',' S '*' S Identifier `value.InnerText = "*" + results[2].Value.InnerText`MoreExterns := ',' S Identifier `value.InnerText = results[1].Value.InnerText`ExternMacro := [A-Z]+ '_EXPORT' S;ExternMacro := [A-Z]+ '_EXTERN' S;# InlineInline := 'NS_INLINE' S Type Identifier '(' S ArgList? ')' S Refcount ';' S;Inline := 'NS_INLINE' S Type Identifier '(' S ArgList? ')' S Body;Inline := 'static' S '__inline__' S Type Identifier '(' S ArgList? ')' S Body;ArgList := Arg (',' S Arg)*;Arg := '...';Arg := Type (Consumed? Identifier ArraySuffix*)?;Body := '{' S ([^{}] / Body)+ '}' S;# InterfaceInterface := Attribute? Deprecated? Availability? Refcount? '@interface' C InterfaceSig ('{' C)? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C;	# work around for lack of preprocessing for types like NSLayoutManagerInterface := Attribute? Deprecated? Availability? Refcount? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C;Attribute := '__attribute__' C '((' S Identifier '))' C;InterfaceMember := Comment / Preprocessor / Method / Enum / Extern / Property / Typedef / ('@optional' S) / ('@required' S);InterfaceSig := Identifier BaseClass C ProtocolList ProtocolList;	# for NSWindowInterfaceSig := Identifier BaseClass C ProtocolList C;InterfaceSig := Identifier BaseClass C;InterfaceSig := Identifier C ProtocolList;InterfaceSig := Identifier Category ProtocolList;InterfaceSig := Identifier Category;BaseClass := ':' S Identifier;Category := '(' S Identifier ')' C;Fields := (Comment / Preprocessor / Access / Field / Struct / Union / Package)*;Access := ('@private' / '@protected' / '@public') S (';' S)?;Field := Volatile? Type FieldNames Availability? Deprecated? ';' S;Field := Volatile? Type Availability? Deprecated? ';' S;				# FieldNames is optional because of the weird function pointer syntaxFieldNames := FieldName (',' S FieldName)*;FieldName := Identifier ArraySuffix+;FieldName := Identifier? ':' S Integer;FieldName := '*' S Identifier;FieldName := Identifier;Package := '@package' S;Property := '@property' S '(' S Identifier ',' S Identifier '=' S Identifier ')' S Field;Property := '@property' S '(' S Identifier '=' S Identifier ')' S Field;Property := '@property' S '(' S Identifier ')' S Field;Property := '@property' S '(' S PropertyArgs ')' S Field;Property := '@property' S Field;PropertyArgs := PropertyArg (S ',' S PropertyArg)* S;PropertyArg := Identifier '=' S MethodName;PropertyArg := Identifier;MethodName := Identifier (':' Identifier?)*;# Method# Not all methods have declared return types (see the NSNaturalLangage category# in NSCalendarDate.h for example).Method := ('-' / '+') S ParensType? (Parameter+ VarArgs? / Identifier) Deprecated? Unavailable? Availability? Format? Refcount? ';' S;Parameter := Identifier? ':' S ParensType? Identifier;VarArgs := ',' S '...' S ('NS_REQUIRES_NIL_TERMINATION' S)?;ParensType := '(' S ParenType C ')' S `value.InnerText = results[1].Value.InnerText`ParenType := Type ArraySuffix* `value.InnerText = text.Trim()`# ProtocolProtocol := Deprecated? Availability? '@protocol' C Identifier ProtocolList? InterfaceMember* '@end' C;ProtocolList := '<' C IdentifierList '>' C `value = results[1].Value`# StructStruct := 'typedef' C Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union / Struct)* '}' C Identifier ArraySuffix* Deprecated? ';' C;Struct := Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union)* '}' C Identifier? ArraySuffix* Deprecated? ';' C;Struct := 'typedef' C Volatile? 'struct' C Identifier Identifier Deprecated? ';' C;Struct := Volatile? 'struct' C Identifier Deprecated? ';' C;Volatile := 'volatile' S;# TypedefTypedef := 'typedef' S Type Identifier '(' S ArgList? ')' S ';' S;Typedef := 'typedef' S PrimitiveType '(' S '*' Identifier ')' S '(' S ArgList? ')' S ';' S;Typedef := 'typedef' S Type Identifier ';' S;Typedef := 'typedef' S 'CALLBACK_API' S '(' S TypeList ')' S '(' S ArgList? ')' S ';' S;# TypeType := Retain? PrimitiveType '(*)' S '(' S TypeList ')' S `value.InnerText = text.Trim()` `expected = "type"`Type := Retain? PrimitiveType '(^' Identifier? ')' S '(' S ArgList ')' S `value.InnerText = text.Trim()` `expected = "type"`Type := Retain? PrimitiveType '(' S '*' S Identifier ')' S '(' S ArgList? ')' S `value.InnerText = text.Trim()` `expected = "type"`Type := Retain? PrimitiveType `value.InnerText = results[0].Value.InnerText` `expected = "type"`Retain := ('CF_RETURNS_RETAINED' / 'NS_RETURNS_RETAINED') S;Consumed := 'CF_CONSUMED' S;TypeList := Type (',' S Type)*;PrimitiveType := ('unsigned' S)? 'long' S 'long' S TypeSuffix* `value.InnerText = text.Trim()`PrimitiveType := 'unsigned' S IntegralType? TypeSuffix* `value.InnerText = text.Trim()`PrimitiveType := Identifier Comment S '*' S `value.InnerText = results[0].Value.InnerText + "*"`PrimitiveType := TypePrefix* (Identifier / BuiltinType) TypeSuffix* `value.InnerText = text.Trim()`TypePrefix := ('const' / 'IBOutlet' / 'inout' / 'oneway' / 'out' / 'signed' / '__strong' / 'struct' / 'unsigned' / '__weak') S;TypeSuffix := ('*' / 'const' / '__strong' / '__weak' / '__unsafe_unretained' / ArraySuffix+ / ProtocolList) S `;` `expected = "type suffix"`	# the array form is used for declarations like: - (void)getPixel:(NSUInteger[])p atX:(NSInteger)x y:(NSInteger)y;ArraySuffix := '[' S (Integer / Identifier)? ']' S;IntegralType := ('char' / 'short' / 'int' / 'long') S;# UnionUnion := 'union' C '{' S (Comment / Preprocessor / Field / Struct)* '}' C Identifier Deprecated? ';' C;# ScaffoldingAvailability := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' S;Availability := '__OSX_AVAILABLE_STARTING' S '(' S IdentifierList ')' S;Availability := 'IOSFC_AVAILABLE_STARTING' S '(' S IdentifierList ')' S;Availability := 'NS_AVAILABLE' [A-Z0-9_]* S VersionList;Availability := 'NS_CLASS_AVAILABLE' S VersionList;Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ S;Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_'  [0-9]+ '_AND_LATER_BUT_DEPRECATED' S;Deprecated := 'DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' C;Deprecated := [A-Z]+ '_DEPRECATED' [A-Z0-9_]* C VersionList?;		# CA_DEPRECATEDDeprecated := '__attribute__((deprecated))' C;Unavailable := 'UNAVAILABLE_ATTRIBUTE' C;Unavailable := 'NS_UNAVAILABLE' C;Refcount := 'NS_AUTOMATED_REFCOUNT_UNAVAILABLE' S ;Format := 'NS_FORMAT_FUNCTION' S '(' S IntegerList ')' S;Float := '-'? [0-9]+ '.' [0-9]+ FloatSuffix? S `;` `expected = "float"`FloatSuffix := 'f';Identifier := IdentifierNoSpace S `value.InnerText = text.Trim()` `expected = "identifier"`IdentifierNoSpace := !Keyword IdentifierStart IdentifierMiddle* `value.InnerText = text.Trim()` `expected = "identifier"`IdentifierStart := [a-zA-Z_] `;` `expected = "identifier"`IdentifierMiddle := [a-zA-Z0-9_] `;` `expected = "identifier characters"`IdentifierList := Identifier (C ',' S Identifier)* C;Keyword := ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'double' / 'do' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'int' / 'long' / 'register' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while') !IdentifierMiddle;BuiltinType := ('char' / 'double' / 'float' / 'int' / 'long' / 'short' / 'void') !IdentifierMiddle S;Integer := '0' [xX] [0-9a-fA-F]+ IntegerSuffix? S `;` `expected = "integer"`Integer := '-'? [0-9]+ IntegerSuffix? S `;` `expected = "integer"`IntegerList := Integer (',' S Integer)*;IntegerSuffix := ('LL' / 'L' / 'ULL' / 'UL' / 'U') S;Version := [a-zA-Z0-9_]+ S;VersionList := '(' S Version (',' S Version)* ')' C;# It would be nice to merge this with the S rule, but then we couldn't# get rid of whitespace with Trim...C := (Comment / Preprocessor / Space)* `text = null`Comment := '/*' (!'*/' .)* '*/' S `;` `expected = "comment"`Comment := '//' [^\n\r]* S `;` `expected = "comment"`Preprocessor := '#' S 'define' [ \t]+ IdentifierNoSpace !'(' DefineValue S `;` `expected = "preprocessor directive"`Preprocessor := '#' S PreprocessName [^\n\r\\]* Continuation* S `;` `expected = "preprocessor directive"`Preprocessor := '__BEGIN_DECLS' S;Preprocessor := '__END_DECLS' S;PreprocessName := 'define' / 'elif' / 'else' / 'endif' / 'error' / 'if' / 'import' / 'include' / 'pragma' / 'undef' / 'warning';DefineValue := [^\n\r\\]+ `value.InnerText = text.Trim()`Continuation := '\\\n' [^\n\r\\]* Continuation*;S := Space* `text = null`Space := [ \t\r\n] `;` `expected = "whitespace"`