// Machine generated by peg-sharp 0.3.377.0 from generate/NewParser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Xml;

[Serializable]
internal sealed class ParserException : Exception
{
	public ParserException()
	{
	}
	
	public ParserException(string message) : base(message)
	{
	}
	
	public ParserException(int line, int col, string file, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
	{
	}
	
	public ParserException(int line, int col, string file, string format, params object[] args) : this(line, col, file, string.Format(format, args))
	{
	}
	
	public ParserException(int line, int col, string file, string message, Exception inner) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."), inner)
	{
	}
	
	[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
	private ParserException(SerializationInfo info, StreamingContext context) : base(info, context)
	{
	}
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class NewParser
{
	public NewParser()
	{
		m_nonterminals.Add("Header", new ParseMethod[]{this.DoParseHeaderRule});
		m_nonterminals.Add("ExternC", new ParseMethod[]{this.DoParseExternCRule});
		m_nonterminals.Add("ExternBegin", new ParseMethod[]{this.DoParseExternBeginRule});
		m_nonterminals.Add("ExternEnd", new ParseMethod[]{this.DoParseExternEndRule});
		m_nonterminals.Add("ForwardReference", new ParseMethod[]{this.DoParseForwardReference1Rule, this.DoParseForwardReference2Rule});
		m_nonterminals.Add("Enum", new ParseMethod[]{this.DoParseEnum1Rule, this.DoParseEnum2Rule});
		m_nonterminals.Add("EnumEntries", new ParseMethod[]{this.DoParseEnumEntriesRule});
		m_nonterminals.Add("EnumEntry", new ParseMethod[]{this.DoParseEnumEntry1Rule, this.DoParseEnumEntry2Rule});
		m_nonterminals.Add("Expression", new ParseMethod[]{this.DoParseExpressionRule});
		m_nonterminals.Add("BinaryOp", new ParseMethod[]{this.DoParseBinaryOpRule});
		m_nonterminals.Add("PrimitiveExpression", new ParseMethod[]{this.DoParsePrimitiveExpression1Rule, this.DoParsePrimitiveExpression2Rule, this.DoParsePrimitiveExpression3Rule, this.DoParsePrimitiveExpression4Rule, this.DoParsePrimitiveExpression5Rule, this.DoParsePrimitiveExpression6Rule});
		m_nonterminals.Add("Extern", new ParseMethod[]{this.DoParseExtern1Rule, this.DoParseExtern2Rule, this.DoParseExtern3Rule, this.DoParseExtern4Rule});
		m_nonterminals.Add("MoreExterns", new ParseMethod[]{this.DoParseMoreExterns1Rule, this.DoParseMoreExterns2Rule});
		m_nonterminals.Add("ExternMacro", new ParseMethod[]{this.DoParseExternMacro1Rule, this.DoParseExternMacro2Rule});
		m_nonterminals.Add("Inline", new ParseMethod[]{this.DoParseInline1Rule, this.DoParseInline2Rule});
		m_nonterminals.Add("ArgList", new ParseMethod[]{this.DoParseArgListRule});
		m_nonterminals.Add("Arg", new ParseMethod[]{this.DoParseArg1Rule, this.DoParseArg2Rule});
		m_nonterminals.Add("Body", new ParseMethod[]{this.DoParseBodyRule});
		m_nonterminals.Add("Interface", new ParseMethod[]{this.DoParseInterface1Rule, this.DoParseInterface2Rule});
		m_nonterminals.Add("Attribute", new ParseMethod[]{this.DoParseAttributeRule});
		m_nonterminals.Add("InterfaceMember", new ParseMethod[]{this.DoParseInterfaceMemberRule});
		m_nonterminals.Add("InterfaceSig", new ParseMethod[]{this.DoParseInterfaceSig1Rule, this.DoParseInterfaceSig2Rule, this.DoParseInterfaceSig3Rule, this.DoParseInterfaceSig4Rule, this.DoParseInterfaceSig5Rule, this.DoParseInterfaceSig6Rule});
		m_nonterminals.Add("BaseClass", new ParseMethod[]{this.DoParseBaseClassRule});
		m_nonterminals.Add("Category", new ParseMethod[]{this.DoParseCategoryRule});
		m_nonterminals.Add("Fields", new ParseMethod[]{this.DoParseFieldsRule});
		m_nonterminals.Add("Access", new ParseMethod[]{this.DoParseAccessRule});
		m_nonterminals.Add("Field", new ParseMethod[]{this.DoParseField1Rule, this.DoParseField2Rule});
		m_nonterminals.Add("FieldNames", new ParseMethod[]{this.DoParseFieldNamesRule});
		m_nonterminals.Add("FieldName", new ParseMethod[]{this.DoParseFieldName1Rule, this.DoParseFieldName2Rule, this.DoParseFieldName3Rule, this.DoParseFieldName4Rule});
		m_nonterminals.Add("Property", new ParseMethod[]{this.DoParseProperty1Rule, this.DoParseProperty2Rule});
		m_nonterminals.Add("PropertyArgs", new ParseMethod[]{this.DoParsePropertyArgsRule});
		m_nonterminals.Add("PropertyArg", new ParseMethod[]{this.DoParsePropertyArg1Rule, this.DoParsePropertyArg2Rule});
		m_nonterminals.Add("MethodName", new ParseMethod[]{this.DoParseMethodNameRule});
		m_nonterminals.Add("Method", new ParseMethod[]{this.DoParseMethodRule});
		m_nonterminals.Add("Parameter", new ParseMethod[]{this.DoParseParameterRule});
		m_nonterminals.Add("VarArgs", new ParseMethod[]{this.DoParseVarArgsRule});
		m_nonterminals.Add("ParensType", new ParseMethod[]{this.DoParseParensTypeRule});
		m_nonterminals.Add("ParenType", new ParseMethod[]{this.DoParseParenTypeRule});
		m_nonterminals.Add("Protocol", new ParseMethod[]{this.DoParseProtocolRule});
		m_nonterminals.Add("ProtocolList", new ParseMethod[]{this.DoParseProtocolListRule});
		m_nonterminals.Add("Struct", new ParseMethod[]{this.DoParseStruct1Rule, this.DoParseStruct2Rule, this.DoParseStruct3Rule, this.DoParseStruct4Rule});
		m_nonterminals.Add("Volatile", new ParseMethod[]{this.DoParseVolatileRule});
		m_nonterminals.Add("Typedef", new ParseMethod[]{this.DoParseTypedef1Rule, this.DoParseTypedef2Rule, this.DoParseTypedef3Rule, this.DoParseTypedef4Rule});
		m_nonterminals.Add("Type", new ParseMethod[]{this.DoParseType1Rule, this.DoParseType2Rule, this.DoParseType3Rule});
		m_nonterminals.Add("TypeList", new ParseMethod[]{this.DoParseTypeListRule});
		m_nonterminals.Add("PrimitiveType", new ParseMethod[]{this.DoParsePrimitiveType1Rule, this.DoParsePrimitiveType2Rule, this.DoParsePrimitiveType3Rule, this.DoParsePrimitiveType4Rule});
		m_nonterminals.Add("TypePrefix", new ParseMethod[]{this.DoParseTypePrefixRule});
		m_nonterminals.Add("TypeSuffix", new ParseMethod[]{this.DoParseTypeSuffixRule});
		m_nonterminals.Add("ArraySuffix", new ParseMethod[]{this.DoParseArraySuffixRule});
		m_nonterminals.Add("IntegralType", new ParseMethod[]{this.DoParseIntegralTypeRule});
		m_nonterminals.Add("Union", new ParseMethod[]{this.DoParseUnionRule});
		m_nonterminals.Add("Availability", new ParseMethod[]{this.DoParseAvailabilityRule});
		m_nonterminals.Add("Deprecated", new ParseMethod[]{this.DoParseDeprecated1Rule, this.DoParseDeprecated2Rule, this.DoParseDeprecated3Rule, this.DoParseDeprecated4Rule});
		m_nonterminals.Add("Float", new ParseMethod[]{this.DoParseFloatRule});
		m_nonterminals.Add("FloatSuffix", new ParseMethod[]{this.DoParseFloatSuffixRule});
		m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifierRule});
		m_nonterminals.Add("IdentifierNoSpace", new ParseMethod[]{this.DoParseIdentifierNoSpaceRule});
		m_nonterminals.Add("IdentifierStart", new ParseMethod[]{this.DoParseIdentifierStartRule});
		m_nonterminals.Add("IdentifierMiddle", new ParseMethod[]{this.DoParseIdentifierMiddleRule});
		m_nonterminals.Add("IdentifierList", new ParseMethod[]{this.DoParseIdentifierListRule});
		m_nonterminals.Add("Keyword", new ParseMethod[]{this.DoParseKeywordRule});
		m_nonterminals.Add("BuiltinType", new ParseMethod[]{this.DoParseBuiltinTypeRule});
		m_nonterminals.Add("Integer", new ParseMethod[]{this.DoParseInteger1Rule, this.DoParseInteger2Rule});
		m_nonterminals.Add("IntegerSuffix", new ParseMethod[]{this.DoParseIntegerSuffixRule});
		m_nonterminals.Add("C", new ParseMethod[]{this.DoParseCRule});
		m_nonterminals.Add("Comment", new ParseMethod[]{this.DoParseComment1Rule, this.DoParseComment2Rule});
		m_nonterminals.Add("Preprocessor", new ParseMethod[]{this.DoParsePreprocessor1Rule, this.DoParsePreprocessor2Rule});
		m_nonterminals.Add("PreprocessName", new ParseMethod[]{this.DoParsePreprocessNameRule});
		m_nonterminals.Add("DefineValue", new ParseMethod[]{this.DoParseDefineValueRule});
		m_nonterminals.Add("Continuation", new ParseMethod[]{this.DoParseContinuationRule});
		m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
		m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
		OnCtorEpilog();
	}
	
	public XmlNode Parse(string input)
	{
		return Parse(input, null);
	}
	
	// File is used for error reporting.
	public XmlNode Parse(string input, string file)
	{
		m_doc = new XmlDocument();
		m_file = file;
		m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";	// add a sentinel so we can avoid range checks
		m_cache.Clear();
		
		State state = new State(0, true);
		var results = new List<Result>();
		
		OnParseProlog();
		state = DoParse(state, results, "Header");
		
		int i = state.Index;
		if (!state.Parsed)
			DoThrow(state.Errors.Index, state.Errors.ToString());
		else if (i < input.Length)
			if (state.Errors.Expected.Length > 0)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else
				DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
		
		m_doc.AppendChild(results[0].Value);
		OnParseEpilog(state);
		
		return m_doc;
	}
	
	#region Non-Terminal Parse Methods
	// Header := S (Comment / Preprocessor / ForwardReference / Enum / ExternC / ExternBegin / ExternEnd / Extern / Inline / Interface / Protocol / Struct / Typedef)*
	private State DoParseHeaderRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Comment"),
					(s3, r3) => DoParse(s3, r3, "Preprocessor"),
					(s3, r3) => DoParse(s3, r3, "ForwardReference"),
					(s3, r3) => DoParse(s3, r3, "Enum"),
					(s3, r3) => DoParse(s3, r3, "ExternC"),
					(s3, r3) => DoParse(s3, r3, "ExternBegin"),
					(s3, r3) => DoParse(s3, r3, "ExternEnd"),
					(s3, r3) => DoParse(s3, r3, "Extern"),
					(s3, r3) => DoParse(s3, r3, "Inline"),
					(s3, r3) => DoParse(s3, r3, "Interface"),
					(s3, r3) => DoParse(s3, r3, "Protocol"),
					(s3, r3) => DoParse(s3, r3, "Struct"),
					(s3, r3) => DoParse(s3, r3, "Typedef"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Header", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternC := 'extern' S '"C"' S '{' S Header '}' S
	private State DoParseExternCRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "extern"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "\"C\""),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Header"),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternC", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value = results[3].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternBegin := [A-Z]+ '_EXTERN_C_BEGIN' S
	private State DoParseExternBeginRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]")),
			(s, r) => DoParseLiteral(s, r, "_EXTERN_C_BEGIN"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternBegin", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternEnd := [A-Z]+ '_EXTERN_C_END' S
	private State DoParseExternEndRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]")),
			(s, r) => DoParseLiteral(s, r, "_EXTERN_C_END"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternEnd", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ForwardReference := ('@class' / '@protocol') S IdentifierList ';' S
	private State DoParseForwardReference1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "@class"),
				(s2, r2) => DoParseLiteral(s2, r2, "@protocol")),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "IdentifierList"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ForwardReference", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ForwardReference := Type ('NP_LOADDS' S)? Identifier '(' S ArgList? ')' S ';' S
	private State DoParseForwardReference2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "NP_LOADDS"),
					(s3, r3) => DoParse(s3, r3, "S"))),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ForwardReference", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Enum := 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Deprecated? ';' C
	private State DoParseEnum1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "enum"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "EnumEntries"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParseLiteral(s2, r2, ",")),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Enum", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Enum := 'typedef' C 'enum' C Identifier? '{' C EnumEntries ','? C '}' C Identifier Deprecated? ';' C
	private State DoParseEnum2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, "enum"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "EnumEntries"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParseLiteral(s2, r2, ",")),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Enum", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntries := EnumEntry (('#else' / (C ',')) C EnumEntry S)*
	private State DoParseEnumEntriesRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "EnumEntry"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoChoice(s3, r3,
						(s4, r4) => DoParseLiteral(s4, r4, "#else"),
						(s4, r4) => DoSequence(s4, r4,
							(s5, r5) => DoParse(s5, r5, "C"),
							(s5, r5) => DoParseLiteral(s5, r5, ","))),
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoParse(s3, r3, "EnumEntry"),
					(s3, r3) => DoParse(s3, r3, "S"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntries", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntry := Identifier '=' S Expression
	private State DoParseEnumEntry1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "="),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Expression"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntry", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EnumEntry := Identifier
	private State DoParseEnumEntry2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("EnumEntry", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Expression := PrimitiveExpression (BinaryOp PrimitiveExpression)*
	private State DoParseExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "PrimitiveExpression"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParse(s3, r3, "BinaryOp"),
					(s3, r3) => DoParse(s3, r3, "PrimitiveExpression"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Expression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "expression";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// BinaryOp := ('+' / '-' / '*' / '/' / '%' / '<<' / '>>' / '&' / '|') S
	private State DoParseBinaryOpRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "+"),
				(s2, r2) => DoParseLiteral(s2, r2, "-"),
				(s2, r2) => DoParseLiteral(s2, r2, "*"),
				(s2, r2) => DoParseLiteral(s2, r2, "/"),
				(s2, r2) => DoParseLiteral(s2, r2, "%"),
				(s2, r2) => DoParseLiteral(s2, r2, "<<"),
				(s2, r2) => DoParseLiteral(s2, r2, ">>"),
				(s2, r2) => DoParseLiteral(s2, r2, "&"),
				(s2, r2) => DoParseLiteral(s2, r2, "|")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BinaryOp", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "binary operator";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Float
	private State DoParsePrimitiveExpression1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Float");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Integer
	private State DoParsePrimitiveExpression2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Integer");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Identifier
	private State DoParsePrimitiveExpression3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := ''\\''' S
	private State DoParsePrimitiveExpression4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "'\\''"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := ''' [^'\r\n]+ ''' S
	private State DoParsePrimitiveExpression5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "'"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, true, "'\r\n", string.Empty, null, "[^'\r\n]")),
			(s, r) => DoParseLiteral(s, r, "'"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "5");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := '(' S Expression ')' S
	private State DoParsePrimitiveExpression6Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Expression"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveExpression", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "6");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := 'extern' S Type Identifier MoreExterns* C Deprecated? Availability? ';' C
	private State DoParseExtern1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "extern"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "MoreExterns")),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := 'extern'? S Type Identifier '(' S ArgList? ')' C Deprecated? Availability? ';' C
	private State DoParseExtern2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParseLiteral(s2, r2, "extern")),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := ExternMacro Type Identifier '(' S ArgList? ')' C Deprecated? Availability? Deprecated? ';' C
	private State DoParseExtern3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "ExternMacro"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Extern := ExternMacro Type Identifier MoreExterns* C Deprecated? Availability? Deprecated? ';' C
	private State DoParseExtern4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "ExternMacro"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "MoreExterns")),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Extern", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MoreExterns := ',' S '*' S Identifier
	private State DoParseMoreExterns1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, ","),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "*"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MoreExterns", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			value.InnerText = "*" + results[2].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MoreExterns := ',' S Identifier
	private State DoParseMoreExterns2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, ","),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MoreExterns", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			value.InnerText = results[1].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternMacro := [A-Z]+ '_EXPORT' S
	private State DoParseExternMacro1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]")),
			(s, r) => DoParseLiteral(s, r, "_EXPORT"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternMacro", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ExternMacro := [A-Z]+ '_EXTERN' S
	private State DoParseExternMacro2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]")),
			(s, r) => DoParseLiteral(s, r, "_EXTERN"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ExternMacro", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Inline := 'NS_INLINE' S Type Identifier '(' S ArgList? ')' S Body
	private State DoParseInline1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "NS_INLINE"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Body"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Inline", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Inline := 'static' S '__inline__' S Type Identifier '(' S ArgList? ')' S Body
	private State DoParseInline2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "static"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "__inline__"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Body"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Inline", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ArgList := Arg (',' S Arg)*
	private State DoParseArgListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Arg"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, ","),
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParse(s3, r3, "Arg"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ArgList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Arg := '...'
	private State DoParseArg1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, "...");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Arg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Arg := Type (Identifier ArraySuffix*)?
	private State DoParseArg2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Identifier"),
					(s3, r3) => DoRepetition(s3, r3, 0, 2147483647,
						(s4, r4) => DoParse(s4, r4, "ArraySuffix")))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Arg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Body := '{' S ([^{}] / Body)+ '}' S
	private State DoParseBodyRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParseRange(s3, r3, true, "{}", string.Empty, null, "[^{}]"),
					(s3, r3) => DoParse(s3, r3, "Body"))),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Body", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Interface := Attribute? Deprecated? Availability? '@interface' C InterfaceSig ('{' C)? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C
	private State DoParseInterface1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Attribute")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, "@interface"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "InterfaceSig"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "{"),
					(s3, r3) => DoParse(s3, r3, "C"))),
			(s, r) => DoParseLiteral(s, r, "@interface"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "InterfaceSig"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "{"),
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoParse(s3, r3, "Fields"),
					(s3, r3) => DoParseLiteral(s3, r3, "}"),
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoRepetition(s3, r3, 0, 1,
						(s4, r4) => DoSequence(s4, r4,
							(s5, r5) => DoParseLiteral(s5, r5, ";"),
							(s5, r5) => DoParse(s5, r5, "S"))))),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "InterfaceMember")),
			(s, r) => DoParseLiteral(s, r, "@end"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Interface", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Interface := Attribute? Deprecated? Availability? '@interface' C InterfaceSig ('{' C Fields '}' C (';' S)?)? InterfaceMember* '@end' C
	private State DoParseInterface2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Attribute")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, "@interface"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "InterfaceSig"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "{"),
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoParse(s3, r3, "Fields"),
					(s3, r3) => DoParseLiteral(s3, r3, "}"),
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoRepetition(s3, r3, 0, 1,
						(s4, r4) => DoSequence(s4, r4,
							(s5, r5) => DoParseLiteral(s5, r5, ";"),
							(s5, r5) => DoParse(s5, r5, "S"))))),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "InterfaceMember")),
			(s, r) => DoParseLiteral(s, r, "@end"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Interface", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Attribute := '__attribute__' C '((' S Identifier '))' C
	private State DoParseAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "__attribute__"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, "(("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "))"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Attribute", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceMember := Comment / Preprocessor / Method / Enum / Extern / Property / Typedef / ('@optional' S) / ('@required' S)
	private State DoParseInterfaceMemberRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoChoice(_state, results,
			(s, r) => DoParse(s, r, "Comment"),
			(s, r) => DoParse(s, r, "Preprocessor"),
			(s, r) => DoParse(s, r, "Method"),
			(s, r) => DoParse(s, r, "Enum"),
			(s, r) => DoParse(s, r, "Extern"),
			(s, r) => DoParse(s, r, "Property"),
			(s, r) => DoParse(s, r, "Typedef"),
			(s, r) => DoSequence(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "@optional"),
				(s2, r2) => DoParse(s2, r2, "S")),
			(s, r) => DoSequence(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "@required"),
				(s2, r2) => DoParse(s2, r2, "S")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceMember", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C ProtocolList ProtocolList
	private State DoParseInterfaceSig1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "BaseClass"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "ProtocolList"),
			(s, r) => DoParse(s, r, "ProtocolList"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C ProtocolList C
	private State DoParseInterfaceSig2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "BaseClass"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "ProtocolList"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier BaseClass C
	private State DoParseInterfaceSig3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "BaseClass"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier C ProtocolList
	private State DoParseInterfaceSig4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "ProtocolList"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier Category ProtocolList
	private State DoParseInterfaceSig5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "Category"),
			(s, r) => DoParse(s, r, "ProtocolList"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "5");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// InterfaceSig := Identifier Category
	private State DoParseInterfaceSig6Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "Category"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("InterfaceSig", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "6");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// BaseClass := ':' S Identifier
	private State DoParseBaseClassRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, ":"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BaseClass", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Category := '(' S Identifier ')' S
	private State DoParseCategoryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Category", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Fields := (Comment / Preprocessor / Access / Field / Struct / Union)*
	private State DoParseFieldsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParse(s2, r2, "Comment"),
				(s2, r2) => DoParse(s2, r2, "Preprocessor"),
				(s2, r2) => DoParse(s2, r2, "Access"),
				(s2, r2) => DoParse(s2, r2, "Field"),
				(s2, r2) => DoParse(s2, r2, "Struct"),
				(s2, r2) => DoParse(s2, r2, "Union")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Fields", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Access := ('@private' / '@protected' / '@public') S (';' S)?
	private State DoParseAccessRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "@private"),
				(s2, r2) => DoParseLiteral(s2, r2, "@protected"),
				(s2, r2) => DoParseLiteral(s2, r2, "@public")),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, ";"),
					(s3, r3) => DoParse(s3, r3, "S"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Access", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Field := Type FieldNames Deprecated? ';' S
	private State DoParseField1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "FieldNames"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Field", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Field := Type Deprecated? ';' S
	private State DoParseField2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Field", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldNames := FieldName (',' S FieldName)*
	private State DoParseFieldNamesRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "FieldName"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, ","),
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParse(s3, r3, "FieldName"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldNames", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier ArraySuffix+
	private State DoParseFieldName1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParse(s2, r2, "ArraySuffix")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier? ':' S Integer
	private State DoParseFieldName2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, ":"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Integer"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := '*' S Identifier
	private State DoParseFieldName3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "*"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FieldName := Identifier
	private State DoParseFieldName4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FieldName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Property := '@property' S '(' S PropertyArgs ')' S Field
	private State DoParseProperty1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "@property"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "PropertyArgs"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Field"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Property", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Property := '@property' S Field
	private State DoParseProperty2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "@property"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Field"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Property", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArgs := PropertyArg (S ',' S PropertyArg)* S
	private State DoParsePropertyArgsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "PropertyArg"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParseLiteral(s3, r3, ","),
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParse(s3, r3, "PropertyArg"))),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArgs", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArg := Identifier '=' S MethodName
	private State DoParsePropertyArg1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "="),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "MethodName"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PropertyArg := Identifier
	private State DoParsePropertyArg2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PropertyArg", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MethodName := Identifier (':' Identifier?)*
	private State DoParseMethodNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, ":"),
					(s3, r3) => DoRepetition(s3, r3, 0, 1,
						(s4, r4) => DoParse(s4, r4, "Identifier")))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("MethodName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Method := ('-' / '+') S ParensType? ((Parameter+ VarArgs?) / Identifier) Deprecated? Availability? ';' S
	private State DoParseMethodRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "-"),
				(s2, r2) => DoParseLiteral(s2, r2, "+")),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ParensType")),
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoRepetition(s3, r3, 1, 2147483647,
						(s4, r4) => DoParse(s4, r4, "Parameter")),
					(s3, r3) => DoRepetition(s3, r3, 0, 1,
						(s4, r4) => DoParse(s4, r4, "VarArgs"))),
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Method", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Parameter := Identifier? ':' S ParensType? Identifier
	private State DoParseParameterRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, ":"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ParensType")),
			(s, r) => DoParse(s, r, "Identifier"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Parameter", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// VarArgs := ',' S '...' S ('NS_REQUIRES_NIL_TERMINATION' S)?
	private State DoParseVarArgsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, ","),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "..."),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "NS_REQUIRES_NIL_TERMINATION"),
					(s3, r3) => DoParse(s3, r3, "S"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("VarArgs", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ParensType := '(' S ParenType C ')' S
	private State DoParseParensTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "ParenType"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ParensType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value.InnerText = results[1].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ParenType := Type ArraySuffix*
	private State DoParseParenTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "ArraySuffix")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ParenType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Protocol := Deprecated? Availability? '@protocol' C Identifier ProtocolList? InterfaceMember* '@end' C
	private State DoParseProtocolRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Availability")),
			(s, r) => DoParseLiteral(s, r, "@protocol"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ProtocolList")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "InterfaceMember")),
			(s, r) => DoParseLiteral(s, r, "@end"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Protocol", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ProtocolList := '<' C IdentifierList '>' C
	private State DoParseProtocolListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "<"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "IdentifierList"),
			(s, r) => DoParseLiteral(s, r, ">"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ProtocolList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			value = results[1].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := 'typedef' C Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union / Struct)* '}' C Identifier ArraySuffix* Deprecated? ';' C
	private State DoParseStruct1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Volatile")),
			(s, r) => DoParseLiteral(s, r, "struct"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Comment"),
					(s3, r3) => DoParse(s3, r3, "Preprocessor"),
					(s3, r3) => DoParse(s3, r3, "Field"),
					(s3, r3) => DoParse(s3, r3, "Union"),
					(s3, r3) => DoParse(s3, r3, "Struct"))),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "ArraySuffix")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := Volatile? 'struct' C Identifier? '{' S (Comment / Preprocessor / Field / Union)* '}' C Identifier? ArraySuffix* Deprecated? ';' C
	private State DoParseStruct2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Volatile")),
			(s, r) => DoParseLiteral(s, r, "struct"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Comment"),
					(s3, r3) => DoParse(s3, r3, "Preprocessor"),
					(s3, r3) => DoParse(s3, r3, "Field"),
					(s3, r3) => DoParse(s3, r3, "Union"))),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Identifier")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "ArraySuffix")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := 'typedef' C Volatile? 'struct' C Identifier Identifier Deprecated? ';' C
	private State DoParseStruct3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Volatile")),
			(s, r) => DoParseLiteral(s, r, "struct"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Struct := Volatile? 'struct' C Identifier Deprecated? ';' C
	private State DoParseStruct4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Volatile")),
			(s, r) => DoParseLiteral(s, r, "struct"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Struct", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Volatile := 'volatile' S
	private State DoParseVolatileRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "volatile"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Volatile", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S Type Identifier '(' S ArgList? ')' S ';' S
	private State DoParseTypedef1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S PrimitiveType '(' S '*' Identifier ')' S '(' S ArgList? ')' S ';' S
	private State DoParseTypedef2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "PrimitiveType"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "*"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S Type Identifier ';' S
	private State DoParseTypedef3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Typedef := 'typedef' S 'CALLBACK_API' S '(' S TypeList ')' S '(' S ArgList? ')' S ';' S
	private State DoParseTypedef4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "typedef"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "CALLBACK_API"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "TypeList"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Typedef", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType '(*)' S '(' S TypeList ')' S
	private State DoParseType1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "PrimitiveType"),
			(s, r) => DoParseLiteral(s, r, "(*)"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "TypeList"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType '(' S '*' S Identifier ')' S '(' S ArgList? ')' S
	private State DoParseType2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "PrimitiveType"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "*"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "("),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "ArgList")),
			(s, r) => DoParseLiteral(s, r, ")"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Type := PrimitiveType
	private State DoParseType3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParse(_state, results, "PrimitiveType");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Type", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			value.InnerText = results[0].Value.InnerText;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// TypeList := Type (',' S Type)*
	private State DoParseTypeListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Type"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, ","),
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParse(s3, r3, "Type"))));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypeList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := ('unsigned' S)? 'long' S 'long' S TypeSuffix*
	private State DoParsePrimitiveType1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParseLiteral(s3, r3, "unsigned"),
					(s3, r3) => DoParse(s3, r3, "S"))),
			(s, r) => DoParseLiteral(s, r, "long"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "long"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "TypeSuffix")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := 'unsigned' S IntegralType? TypeSuffix*
	private State DoParsePrimitiveType2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "unsigned"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "IntegralType")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "TypeSuffix")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := Identifier Comment S '*' S
	private State DoParsePrimitiveType3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoParse(s, r, "Comment"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "*"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			value.InnerText = results[0].Value.InnerText + "*";
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveType := TypePrefix* (Identifier / BuiltinType) TypeSuffix*
	private State DoParsePrimitiveType4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "TypePrefix")),
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParse(s2, r2, "Identifier"),
				(s2, r2) => DoParse(s2, r2, "BuiltinType")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "TypeSuffix")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PrimitiveType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TypePrefix := ('const' / 'IBOutlet' / 'inout' / 'oneway' / 'out' / 'signed' / '__strong' / 'struct' / 'unsigned' / '__weak') S
	private State DoParseTypePrefixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "const"),
				(s2, r2) => DoParseLiteral(s2, r2, "IBOutlet"),
				(s2, r2) => DoParseLiteral(s2, r2, "inout"),
				(s2, r2) => DoParseLiteral(s2, r2, "oneway"),
				(s2, r2) => DoParseLiteral(s2, r2, "out"),
				(s2, r2) => DoParseLiteral(s2, r2, "signed"),
				(s2, r2) => DoParseLiteral(s2, r2, "__strong"),
				(s2, r2) => DoParseLiteral(s2, r2, "struct"),
				(s2, r2) => DoParseLiteral(s2, r2, "unsigned"),
				(s2, r2) => DoParseLiteral(s2, r2, "__weak")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypePrefix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TypeSuffix := ('*' / 'const' / '__strong' / '__weak' / ArraySuffix+ / ProtocolList) S
	private State DoParseTypeSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "*"),
				(s2, r2) => DoParseLiteral(s2, r2, "const"),
				(s2, r2) => DoParseLiteral(s2, r2, "__strong"),
				(s2, r2) => DoParseLiteral(s2, r2, "__weak"),
				(s2, r2) => DoRepetition(s2, r2, 1, 2147483647,
					(s3, r3) => DoParse(s3, r3, "ArraySuffix")),
				(s2, r2) => DoParse(s2, r2, "ProtocolList")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("TypeSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "type suffix";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// ArraySuffix := '[' S (Integer / Identifier)? ']' S
	private State DoParseArraySuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "["),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Integer"),
					(s3, r3) => DoParse(s3, r3, "Identifier"))),
			(s, r) => DoParseLiteral(s, r, "]"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("ArraySuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IntegralType := ('char' / 'short' / 'int' / 'long') S
	private State DoParseIntegralTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "char"),
				(s2, r2) => DoParseLiteral(s2, r2, "short"),
				(s2, r2) => DoParseLiteral(s2, r2, "int"),
				(s2, r2) => DoParseLiteral(s2, r2, "long")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IntegralType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Union := 'union' C '{' S (Comment / Preprocessor / Field / Struct)* '}' C Identifier Deprecated? ';' C
	private State DoParseUnionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "union"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParseLiteral(s, r, "{"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoChoice(s2, r2,
					(s3, r3) => DoParse(s3, r3, "Comment"),
					(s3, r3) => DoParse(s3, r3, "Preprocessor"),
					(s3, r3) => DoParse(s3, r3, "Field"),
					(s3, r3) => DoParse(s3, r3, "Struct"))),
			(s, r) => DoParseLiteral(s, r, "}"),
			(s, r) => DoParse(s, r, "C"),
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "Deprecated")),
			(s, r) => DoParseLiteral(s, r, ";"),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Union", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Availability := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' S
	private State DoParseAvailabilityRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParseLiteral(s, r, "_AND_LATER"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Availability", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ S
	private State DoParseDeprecated1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParseLiteral(s, r, "_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'AVAILABLE_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER_BUT_DEPRECATED' S
	private State DoParseDeprecated2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "AVAILABLE_MAC_OS_X_VERSION_10_"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParseLiteral(s, r, "_AND_LATER_BUT_DEPRECATED"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := 'DEPRECATED_IN_MAC_OS_X_VERSION_10_' [0-9]+ '_AND_LATER' S
	private State DoParseDeprecated3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "DEPRECATED_IN_MAC_OS_X_VERSION_10_"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParseLiteral(s, r, "_AND_LATER"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "3");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Deprecated := [A-Z]+ '_DEPRECATED' S
	private State DoParseDeprecated4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "AZ", null, "[A-Z]")),
			(s, r) => DoParseLiteral(s, r, "_DEPRECATED"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Deprecated", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "4");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Float := '-'? [0-9]+ '.' [0-9]+ FloatSuffix? S
	private State DoParseFloatRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParseLiteral(s2, r2, "-")),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoParseLiteral(s, r, "."),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "FloatSuffix")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Float", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "float";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// FloatSuffix := 'f'
	private State DoParseFloatSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, "f");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("FloatSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Identifier := IdentifierNoSpace S
	private State DoParseIdentifierRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "IdentifierNoSpace"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Identifier", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierNoSpace := !Keyword IdentifierStart IdentifierMiddle*
	private State DoParseIdentifierNoSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoNAssert(s, r,
				(s2, r2) => DoParse(s2, r2, "Keyword")),
			(s, r) => DoParse(s, r, "IdentifierStart"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "IdentifierMiddle")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierNoSpace", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierStart := [_a-zA-Z]
	private State DoParseIdentifierStartRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, "_", "azAZ", null, "[_a-zA-Z]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierStart", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierMiddle := [_a-zA-Z0-9]
	private State DoParseIdentifierMiddleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, "_", "azAZ09", null, "[_a-zA-Z0-9]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierMiddle", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier characters";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdentifierList := Identifier (C ',' S Identifier)* C
	private State DoParseIdentifierListRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParse(s, r, "Identifier"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoParse(s3, r3, "C"),
					(s3, r3) => DoParseLiteral(s3, r3, ","),
					(s3, r3) => DoParse(s3, r3, "S"),
					(s3, r3) => DoParse(s3, r3, "Identifier"))),
			(s, r) => DoParse(s, r, "C"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IdentifierList", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Keyword := ('auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' / 'double' / 'do' / 'else' / 'enum' / 'extern' / 'float' / 'for' / 'goto' / 'if' / 'int' / 'long' / 'register' / 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' / 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' / 'while') !IdentifierMiddle
	private State DoParseKeywordRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "auto"),
				(s2, r2) => DoParseLiteral(s2, r2, "break"),
				(s2, r2) => DoParseLiteral(s2, r2, "case"),
				(s2, r2) => DoParseLiteral(s2, r2, "char"),
				(s2, r2) => DoParseLiteral(s2, r2, "const"),
				(s2, r2) => DoParseLiteral(s2, r2, "continue"),
				(s2, r2) => DoParseLiteral(s2, r2, "default"),
				(s2, r2) => DoParseLiteral(s2, r2, "double"),
				(s2, r2) => DoParseLiteral(s2, r2, "do"),
				(s2, r2) => DoParseLiteral(s2, r2, "else"),
				(s2, r2) => DoParseLiteral(s2, r2, "enum"),
				(s2, r2) => DoParseLiteral(s2, r2, "extern"),
				(s2, r2) => DoParseLiteral(s2, r2, "float"),
				(s2, r2) => DoParseLiteral(s2, r2, "for"),
				(s2, r2) => DoParseLiteral(s2, r2, "goto"),
				(s2, r2) => DoParseLiteral(s2, r2, "if"),
				(s2, r2) => DoParseLiteral(s2, r2, "int"),
				(s2, r2) => DoParseLiteral(s2, r2, "long"),
				(s2, r2) => DoParseLiteral(s2, r2, "register"),
				(s2, r2) => DoParseLiteral(s2, r2, "return"),
				(s2, r2) => DoParseLiteral(s2, r2, "short"),
				(s2, r2) => DoParseLiteral(s2, r2, "signed"),
				(s2, r2) => DoParseLiteral(s2, r2, "sizeof"),
				(s2, r2) => DoParseLiteral(s2, r2, "static"),
				(s2, r2) => DoParseLiteral(s2, r2, "struct"),
				(s2, r2) => DoParseLiteral(s2, r2, "switch"),
				(s2, r2) => DoParseLiteral(s2, r2, "typedef"),
				(s2, r2) => DoParseLiteral(s2, r2, "union"),
				(s2, r2) => DoParseLiteral(s2, r2, "unsigned"),
				(s2, r2) => DoParseLiteral(s2, r2, "void"),
				(s2, r2) => DoParseLiteral(s2, r2, "volatile"),
				(s2, r2) => DoParseLiteral(s2, r2, "while")),
			(s, r) => DoNAssert(s, r,
				(s2, r2) => DoParse(s2, r2, "IdentifierMiddle")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Keyword", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// BuiltinType := ('char' / 'double' / 'float' / 'int' / 'long' / 'short' / 'void') !IdentifierMiddle S
	private State DoParseBuiltinTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "char"),
				(s2, r2) => DoParseLiteral(s2, r2, "double"),
				(s2, r2) => DoParseLiteral(s2, r2, "float"),
				(s2, r2) => DoParseLiteral(s2, r2, "int"),
				(s2, r2) => DoParseLiteral(s2, r2, "long"),
				(s2, r2) => DoParseLiteral(s2, r2, "short"),
				(s2, r2) => DoParseLiteral(s2, r2, "void")),
			(s, r) => DoNAssert(s, r,
				(s2, r2) => DoParse(s2, r2, "IdentifierMiddle")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("BuiltinType", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Integer := '0' [xX] [0-9a-fA-F]+ IntegerSuffix? S
	private State DoParseInteger1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "0"),
			(s, r) => DoParseRange(s, r, false, "xX", string.Empty, null, "[xX]"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09afAF", null, "[0-9a-fA-F]")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "IntegerSuffix")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Integer", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "integer";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Integer := '-'? [0-9]+ IntegerSuffix? S
	private State DoParseInteger2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParseLiteral(s2, r2, "-")),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]")),
			(s, r) => DoRepetition(s, r, 0, 1,
				(s2, r2) => DoParse(s2, r2, "IntegerSuffix")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Integer", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "integer";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IntegerSuffix := ('L' / 'UL' / 'U') S
	private State DoParseIntegerSuffixRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "L"),
				(s2, r2) => DoParseLiteral(s2, r2, "UL"),
				(s2, r2) => DoParseLiteral(s2, r2, "U")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("IntegerSuffix", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// C := (Comment / Preprocessor / Space)*
	private State DoParseCRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			(s, r) => DoChoice(s, r,
				(s2, r2) => DoParse(s2, r2, "Comment"),
				(s2, r2) => DoParse(s2, r2, "Preprocessor"),
				(s2, r2) => DoParse(s2, r2, "Space")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("C", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Comment := '/*' (!'*/' .)* '*/' S
	private State DoParseComment1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "/*"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoSequence(s2, r2,
					(s3, r3) => DoNAssert(s3, r3,
						(s4, r4) => DoParseLiteral(s4, r4, "*/")),
					(s3, r3) => DoParseRange(s3, r3, false, string.Empty, "\x0001\xFFFF", null, "."))),
			(s, r) => DoParseLiteral(s, r, "*/"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Comment", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "comment";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Comment := '//' [^\n\r]* S
	private State DoParseComment2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "//"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, true, "\n\r", string.Empty, null, "[^\n\r]")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Comment", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "comment";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Preprocessor := '#' S 'define' [ \t]+ IdentifierNoSpace !'(' DefineValue S
	private State DoParsePreprocessor1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "#"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParseLiteral(s, r, "define"),
			(s, r) => DoRepetition(s, r, 1, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, false, " \t", string.Empty, null, "[ \t]")),
			(s, r) => DoParse(s, r, "IdentifierNoSpace"),
			(s, r) => DoNAssert(s, r,
				(s2, r2) => DoParseLiteral(s2, r2, "(")),
			(s, r) => DoParse(s, r, "DefineValue"),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Preprocessor", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "1");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "preprocessor directive";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Preprocessor := '#' S PreprocessName [^\n\r\\]* Continuation* S
	private State DoParsePreprocessor2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "#"),
			(s, r) => DoParse(s, r, "S"),
			(s, r) => DoParse(s, r, "PreprocessName"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, true, "\n\r\\", string.Empty, null, "[^\n\r\\]")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "Continuation")),
			(s, r) => DoParse(s, r, "S"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Preprocessor", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			_node.SetAttribute("alternative", "2");
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "preprocessor directive";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// PreprocessName := 'define' / 'elif' / 'else' / 'endif' / 'error' / 'if' / 'import' / 'include' / 'pragma' / 'undef' / 'warning'
	private State DoParsePreprocessNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoChoice(_state, results,
			(s, r) => DoParseLiteral(s, r, "define"),
			(s, r) => DoParseLiteral(s, r, "elif"),
			(s, r) => DoParseLiteral(s, r, "else"),
			(s, r) => DoParseLiteral(s, r, "endif"),
			(s, r) => DoParseLiteral(s, r, "error"),
			(s, r) => DoParseLiteral(s, r, "if"),
			(s, r) => DoParseLiteral(s, r, "import"),
			(s, r) => DoParseLiteral(s, r, "include"),
			(s, r) => DoParseLiteral(s, r, "pragma"),
			(s, r) => DoParseLiteral(s, r, "undef"),
			(s, r) => DoParseLiteral(s, r, "warning"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("PreprocessName", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DefineValue := [^\n\r\\]+
	private State DoParseDefineValueRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			(s, r) => DoParseRange(s, r, true, "\n\r\\", string.Empty, null, "[^\n\r\\]"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("DefineValue", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value.InnerText = text.Trim();
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Continuation := '\\\n' [^\n\r\\]* Continuation*
	private State DoParseContinuationRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoSequence(_state, results,
			(s, r) => DoParseLiteral(s, r, "\\\n"),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParseRange(s2, r2, true, "\n\r\\", string.Empty, null, "[^\n\r\\]")),
			(s, r) => DoRepetition(s, r, 0, 2147483647,
				(s2, r2) => DoParse(s2, r2, "Continuation")));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Continuation", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// S := Space*
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			(s, r) => DoParse(s, r, "Space"));
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("S", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Space := [ \t\r\n]
	private State DoParseSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		var results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
		
		if (_state.Parsed)
		{
			XmlElement _node = DoCreateElementNode("Space", _start.Index, _state.Index - _start.Index, DoGetLine(_start.Index), DoGetCol(_start.Index), (from r in results where r.Value != null select r.Value).ToArray());
			XmlNode value = _node;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "whitespace";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
	
	public string DoEscapeAll(string s)
	{
		var builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	// This is normally only used for error handling so it doesn't need to be too
	// fast. If it somehow does become a bottleneck for some parsers they can
	// replace it with the custom-methods setting.
	private int DoGetLine(int index)
	{
		int line = 1;
		
		int i = 0;
		while (i <= index)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				++i;
				++line;
			}
			else if (ch == '\r')
			{
				++line;
			}
			else if (ch == '\n')
			{
				++line;
			}
		}
		
		return line;
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index + 1;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index);
	
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, m_file, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, m_file, DoEscapeAll(format));
	}
	
	private XmlText DoCreateTextNode(string data, int line, int col)
	{
		XmlText node = m_doc.CreateTextNode(data);
		
		return node;
	}
	
	private XmlElement DoCreateElementNode(string name, int offset, int length, int line, int col, XmlNode[] children)
	{
		XmlElement node = m_doc.CreateElement(name);
		
		node.SetAttribute("offset", offset.ToString());
		node.SetAttribute("length", length.ToString());
		node.SetAttribute("line", line.ToString());
		node.SetAttribute("col", col.ToString());
		
		foreach (XmlNode child in children)
			node.AppendChild(child);
		
		return node;
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		int j = state.Index;
		
		for (int i = 0; i < literal.Length; ++i)
		{
			if (m_input[j + i] != literal[i])
			{
				return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
			}
		}
		
		int k = j + literal.Length;
		
		results.Add(new Result(this, j, literal.Length, m_input, DoCreateTextNode(literal, DoGetLine(j), DoGetCol(j))));
		state = new State(k, true, state.Errors);
		
		return state;
	}
	
	private State DoParse(State state, List<Result> results, string nonterminal)
	{
		State start = state;
		
		CacheValue cache;
		CacheKey key = new CacheKey(nonterminal, start.Index);
		if (!m_cache.TryGetValue(key, out cache))
		{
			ParseMethod[] methods = m_nonterminals[nonterminal];
			
			int oldCount = results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && results.Count > oldCount;
			XmlNode value = hasResult ? results[results.Count - 1].Value : default(XmlNode);
			cache = new CacheValue(state, value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult)
				results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
		}
		
		return cache.State;
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
				break;
			}
		}
		
		return state;
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		State start = state;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
				state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
				break;
			}
		}
		
		if (count < min || count > max)
			state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
		
		return state;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
			results.Add(new Result(this, state.Index, 1, m_input, DoCreateTextNode(m_input.Substring(state.Index, 1), DoGetLine(state.Index), DoGetCol(state.Index))));
			return new State(state.Index + 1, true, state.Errors);
		}
		
		return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
	}
	
	private State DoNAssert(State state, List<Result> results, ParseMethod method)
	{
		State temp = method(state, results);
		
		state = new State(state.Index, !temp.Parsed, state.Errors);
		
		return state;
	}
	#endregion
	
	#region Private Types
	private struct CacheKey : IEquatable<CacheKey>
	{
		public CacheKey(string rule, int index)
		{
			m_rule = rule;
			m_index = index;
		}
		
		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			
			if (GetType() != obj.GetType())
				return false;
			
			CacheKey rhs = (CacheKey) obj;
			return this == rhs;
		}
		
		public bool Equals(CacheKey rhs)
		{
			return this == rhs;
		}
		
		public static bool operator==(CacheKey lhs, CacheKey rhs)
		{
			if (lhs.m_rule != rhs.m_rule)
				return false;
			
			if (lhs.m_index != rhs.m_index)
				return false;
			
			return true;
		}
		
		public static bool operator!=(CacheKey lhs, CacheKey rhs)
		{
			return !(lhs == rhs);
		}
		
		public override int GetHashCode()
		{
			int hash = 0;
			
			unchecked
			{
				hash += m_rule.GetHashCode();
				hash += m_index.GetHashCode();
			}
			
			return hash;
		}
		
		private string m_rule;
		private int m_index;
	}
	
	private struct CacheValue
	{
		public CacheValue(State state, XmlNode value, bool hasResult)
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State {get; private set;}
		
		public XmlNode Value {get; private set;}
		
		public bool HasResult {get; private set;}
	}
	
	private delegate State ParseMethod(State state, List<Result> results);
	
	// These are either an error that caused parsing to fail or the reason a
	// successful parse stopped.
	private struct ErrorSet
	{
		public ErrorSet(int index, string expected)
		{
			Index = index;
			Expected = new string[]{expected};
		}
		
		public ErrorSet(int index, string[] expected)
		{
			Index = index;
			Expected = expected;
		}
		
		// The location associated with the errors. For a failed parse this will be the
		// same as State.Index. For a successful parse it will be State.Index or later.
		public int Index {get; private set;}
		
		// This will be the name of something which was expected, but not found.
		public string[] Expected {get; private set;}
		
		public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
		{
			if (lhs.Index > rhs.Index)
			{
				return lhs;
			}
			else if (lhs.Index < rhs.Index)
			{
				return rhs;
			}
			else
			{
				var errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
				errors.AddRange(lhs.Expected);
				foreach (string err in rhs.Expected)
				{
					if (errors.IndexOf(err) < 0)
						errors.Add(err);
				}
				return new ErrorSet(lhs.Index, errors.ToArray());
			}
		}
		
		public override string ToString()
		{
			if (Expected.Length > 0)
				return string.Format("Expected {0}", string.Join(" or ", Expected));
			else
				return "<none>";
		}
	}
	
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
			Errors = new ErrorSet(index, new string[0]);
		}
		
		public State(int index, bool parsed, ErrorSet errors)
		{
			Index = index;
			Parsed = parsed;
			Errors = errors;
		}
		
		// Index of the first unconsumed character.
		public int Index {get; private set;}
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed {get; private set;}
		
		// If Parsed is false then this will explain why. If Parsed is true it will
		// say why the parse stopped.
		public ErrorSet Errors {get; private set;}
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
		public Result(NewParser parser, int index, int length, string input, XmlNode value)
		{
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
		
		// For non-terminals this will be the result of the semantic action, 
		// otherwise it will be the default value.
		public XmlNode Value {get; private set;}
		
		private NewParser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
	
	#endregion
	
	#region Fields
	private string m_input;
	private string m_file;
	private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
	private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
	private XmlDocument m_doc;
	#endregion
}
